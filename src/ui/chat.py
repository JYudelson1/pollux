# NB: This Code was mostly generated by Claude

from src.api import Conversation, Channel
from src.utils import get_raw_text, ROOT
from src.scaffolding.xml_parser import parse_claude_output, ParsedTag

import curses
import textwrap
import signal
import os
import time
from curses.textpad import rectangle
from typing import List, Tuple

class EnhancedTextbox:
    def __init__(self, win):
        self.win = win
        self.height, self.width = win.getmaxyx()
        self.buffer: List[str] = []
        self.cursor_pos = 0
        self.first_visible_line = 0
        self.target_cursor_x = 0
        self.win.keypad(1)
        self.last_char_time = 0

    def get_cursor_visual_pos(self) -> Tuple[int, int]:
        """Calculate cursor's visual position based on buffer position"""
        text_before_cursor = ''.join(self.buffer[:self.cursor_pos])
        lines_before_cursor = text_before_cursor.split('\n')
        
        # Cursor's line number
        cursor_y = len(lines_before_cursor) - 1
        
        # Position in current line
        current_line = lines_before_cursor[-1]
        # Handle line wrapping
        wrapped_lines_before = []
        for i, line in enumerate(lines_before_cursor[:-1]):
            wrapped_lines_before.extend(textwrap.wrap(line, self.width - 1) or [''])
        
        current_line_wrapped = textwrap.wrap(current_line, self.width - 1) or ['']
        cursor_y = len(wrapped_lines_before) + len(current_line_wrapped) - 1
        
        # Position in final wrapped line
        if current_line:
            last_part_len = len(current_line) % (self.width - 1)
            cursor_x = last_part_len if last_part_len > 0 else len(current_line_wrapped[-1])
        else:
            cursor_x = 0
            
        return cursor_y, cursor_x

    def ensure_cursor_visible(self):
        """Adjust scroll position to keep cursor visible"""
        cursor_y, _ = self.get_cursor_visual_pos()
        
        # If cursor is below visible area, scroll down
        while cursor_y - self.first_visible_line >= self.height:
            self.first_visible_line += 1
            
        # If cursor is above visible area, scroll up
        while cursor_y < self.first_visible_line:
            self.first_visible_line = cursor_y

    def render(self):
        """Render the textbox contents"""
        self.win.erase()
        
        # Get complete text and wrap it
        text = ''.join(self.buffer)
        wrapped_lines = []
        for line in text.split('\n'):
            if line:
                wrapped_lines.extend(textwrap.wrap(line, self.width - 1) or [''])
            else:
                wrapped_lines.append('')
                
        # Display visible portion
        display_lines = wrapped_lines[self.first_visible_line:self.first_visible_line + self.height]
        for i, line in enumerate(display_lines):
            if i < self.height:
                self.win.addstr(i, 0, line[:self.width-1])
        
        # Position cursor
        cursor_y, cursor_x = self.get_cursor_visual_pos()
        screen_y = cursor_y - self.first_visible_line
        try:
            self.win.move(screen_y, cursor_x)
        except curses.error:
            pass
        
        self.win.refresh()

    def is_pasting(self) -> bool:
        current_time = time.time()
        is_paste = (current_time - self.last_char_time) < 0.01
        self.last_char_time = current_time
        return is_paste

    def insert_char(self, ch: str):
        self.buffer.insert(self.cursor_pos, ch)
        self.cursor_pos += 1
        self.ensure_cursor_visible()

    def insert_newline(self):
        self.buffer.insert(self.cursor_pos, '\n')
        self.cursor_pos += 1
        self.ensure_cursor_visible()

    def backspace(self):
        if self.cursor_pos > 0:
            self.buffer.pop(self.cursor_pos - 1)
            self.cursor_pos -= 1
            self.ensure_cursor_visible()

    def move_cursor_left(self):
        if self.cursor_pos > 0:
            self.cursor_pos -= 1
            self.ensure_cursor_visible()

    def move_cursor_right(self):
        if self.cursor_pos < len(self.buffer):
            self.cursor_pos += 1
            self.ensure_cursor_visible()

    def move_cursor_up(self):
        # Find the previous line's equivalent position
        cursor_y, cursor_x = self.get_cursor_visual_pos()
        if cursor_y > 0:
            # Move cursor to beginning of current line
            text = ''.join(self.buffer)
            lines = text.split('\n')
            pos = self.cursor_pos
            while pos > 0 and text[pos-1] != '\n':
                pos -= 1
            # Then move back to previous line
            if pos > 0:
                pos -= 1
                while pos > 0 and text[pos-1] != '\n':
                    pos -= 1
                # Move to equivalent x position
                self.cursor_pos = pos + min(cursor_x, len(text[pos:].split('\n')[0]))
                self.ensure_cursor_visible()

    def move_cursor_down(self):
        # Find the next line's equivalent position
        cursor_y, cursor_x = self.get_cursor_visual_pos()
        text = ''.join(self.buffer)
        lines = text.split('\n')
        if cursor_y < len(lines) - 1:
            # Move cursor to end of current line
            pos = self.cursor_pos
            while pos < len(text) and text[pos] != '\n':
                pos += 1
            # Then move to next line
            if pos < len(text):
                pos += 1
                # Move to equivalent x position
                next_line_end = pos
                while next_line_end < len(text) and text[next_line_end] != '\n':
                    next_line_end += 1
                self.cursor_pos = pos + min(cursor_x, next_line_end - pos)
                self.ensure_cursor_visible()

    def edit(self, ch: int) -> bool:
        pasting = self.is_pasting()
        
        if ch == 9:  # Tab key
            self.insert_newline()
            return False
        
        if ch in (10, 13):  # Enter or pasted newline
            if pasting:
                self.insert_newline()
                return False
            return True
            
        elif ch in (curses.KEY_BACKSPACE, 127):
            self.backspace()
            
        elif ch == curses.KEY_LEFT:
            self.move_cursor_left()
            
        elif ch == curses.KEY_RIGHT:
            self.move_cursor_right()
            
        elif ch == curses.KEY_UP:
            self.move_cursor_up()
            
        elif ch == curses.KEY_DOWN:
            self.move_cursor_down()
            
        elif 32 <= ch <= 126:  # Printable characters
            self.insert_char(chr(ch))
        
        self.render()
        return False

    def get_value(self) -> str:
        return ''.join(self.buffer)

    def clear(self):
        self.buffer = []
        self.cursor_pos = 0
        self.first_visible_line = 0
        self.target_cursor_x = 0
        self.render()


class ChatTUI:
    def __init__(self, stdscr, conversation: Conversation):
        self.stdscr = stdscr
        self.conversation = conversation
        self.chat_history = []
        self.raw_content = ""
        self.tool_calls_content = ""

        # Only enable scroll events, let terminal handle selection
        curses.mousemask(curses.BUTTON4_PRESSED | 
                    curses.BUTTON2_PRESSED | 
                    curses.REPORT_MOUSE_POSITION)
        print('\033[?1003h')

        # Initialize colors
        curses.start_color()
        curses.init_pair(1, curses.COLOR_WHITE, curses.COLOR_BLACK)
        curses.init_pair(2, curses.COLOR_GREEN, curses.COLOR_BLACK)
        curses.init_pair(3, curses.COLOR_YELLOW, curses.COLOR_BLACK)

        # Initialize scroll positions
        self.chat_scroll = 0
        self.raw_scroll = 0
        self.tool_calls_scroll = 0
        self.total_chat_lines = 0

        self.resize_terminal()
        signal.signal(signal.SIGWINCH, self.handle_resize)

    def resize_terminal(self):
        self.height, self.width = self.stdscr.getmaxyx()
        self.input_reserve = 8
        self.usable_height = self.height - self.input_reserve
        self.chat_width = self.width // 2
        self.side_width = self.width - self.chat_width - 3
        self.raw_height = (self.usable_height - 2) * 2 // 3
        self.tool_height = self.usable_height - self.raw_height - 4

        self.setup_windows()
        self.stdscr.clear()
        self.draw_borders()
        self.update_chat_window()
        self.update_raw_window()
        self.update_tool_calls_window()
        self.stdscr.refresh()

    def handle_resize(self, *args):
        curses.endwin()
        curses.initscr()
        self.resize_terminal()

    def setup_windows(self):
        self.chat_win = curses.newwin(self.usable_height - 2, self.chat_width - 2, 2, 2)
        self.chat_win.scrollok(True)

        self.raw_win = curses.newwin(
            self.raw_height, self.side_width, 2, self.chat_width + 1
        )
        self.raw_win.scrollok(True)

        self.tool_calls_win = curses.newwin(
            self.tool_height, self.side_width, self.raw_height + 3, self.chat_width + 1
        )
        self.tool_calls_win.scrollok(True)

        self.input_win = curses.newwin(6, self.width - 4, self.height - 7, 2)
        self.textbox = EnhancedTextbox(self.input_win)

        for win in [
            self.stdscr,
            self.input_win,
            self.chat_win,
            self.raw_win,
            self.tool_calls_win,
        ]:
            win.keypad(1)

    def handle_mouse(self):
        try:
            _, mx, my, _, bstate = curses.getmouse()
            scroll_happened = False
            
            # Debug logging
            with open("/tmp/mouse_debug.txt", "a") as f:
                f.write(f"Mouse event: x={mx}, y={my}, bstate={bin(bstate)} ({hex(bstate)})\n")
            
            # Check if the click is within the chat window
            if 2 <= mx < self.chat_width and 2 <= my < self.usable_height:
                if bstate & curses.BUTTON4_PRESSED:  # Scroll up
                    if self.chat_scroll > 0:
                        self.chat_scroll -= 1
                        scroll_happened = True
                elif bstate & curses.BUTTON2_PRESSED:  # Scroll down - exact match!
                    max_scroll = max(0, self.total_chat_lines - (self.usable_height-4))
                    if self.chat_scroll < max_scroll:
                        self.chat_scroll += 1
                        scroll_happened = True
            
            # Check if the click is within the raw window
            elif self.chat_width+1 <= mx < self.width-2 and 2 <= my < self.raw_height+2:
                if bstate & curses.BUTTON4_PRESSED:  # Scroll up
                    if self.raw_scroll > 0:
                        self.raw_scroll -= 1
                        scroll_happened = True
                elif bstate & curses.BUTTON2_PRESSED:  # Scroll down - exact match!
                    self.raw_scroll += 1
                    scroll_happened = True
            
            if scroll_happened:
                self.update_chat_window()
                self.update_raw_window()
                
        except curses.error:
            pass

    def draw_borders(self):
        try:
            rectangle(self.stdscr, 1, 1, self.usable_height, self.chat_width)
            rectangle(
                self.stdscr, 1, self.chat_width, self.raw_height + 2, self.width - 2
            )
            rectangle(
                self.stdscr,
                self.raw_height + 2,
                self.chat_width,
                self.usable_height,
                self.width - 2,
            )
            rectangle(self.stdscr, self.height - 7, 1, self.height - 1, self.width - 2)

            self.stdscr.addstr(1, 2, " Chat History ", curses.color_pair(2))
            self.stdscr.addstr(
                1, self.chat_width + 1, " Raw Output ", curses.color_pair(2)
            )
            self.stdscr.addstr(
                self.raw_height + 2,
                self.chat_width + 1,
                " Tool Calls ",
                curses.color_pair(2),
            )

            self.stdscr.refresh()
        except curses.error:
            pass

    def format_chat_history(self):
        formatted_lines = []
        for message in self.chat_history:
            # Split the message into lines first
            message_lines = message.split("\n")
            for line in message_lines:
                # Wrap each line individually
                if line:
                    wrapped_lines = textwrap.fill(line, self.chat_width - 4).split("\n")
                    formatted_lines.extend(wrapped_lines)
                else:
                    # Preserve empty lines
                    formatted_lines.append("")
            # Add spacing between messages
            formatted_lines.extend([""])

        self.total_chat_lines = len(formatted_lines)
        return formatted_lines

    def update_chat_window(self):
        try:
            self.chat_win.erase()
            lines = self.format_chat_history()

            display_lines = lines[
                self.chat_scroll : self.chat_scroll + (self.usable_height - 4)
            ]
            for i, line in enumerate(display_lines):
                if i < (self.usable_height - 4):
                    self.chat_win.addstr(i, 0, line[: self.chat_width - 4])

            self.chat_win.refresh()
        except curses.error:
            pass

    def update_raw_window(self):
        try:
            self.raw_win.erase()
            wrapped_content = textwrap.fill(self.raw_content, self.side_width - 2)
            lines = wrapped_content.split("\n")

            display_lines = lines[self.raw_scroll : self.raw_scroll + self.raw_height]
            for i, line in enumerate(display_lines):
                if i < self.raw_height:
                    self.raw_win.addstr(i, 0, line[: self.side_width - 2])

            self.raw_win.refresh()
        except curses.error:
            pass

    def update_tool_calls_window(self):
        try:
            self.tool_calls_win.erase()
            wrapped_content = textwrap.fill(
                str(self.tool_calls_content), self.side_width - 2
            )
            lines = wrapped_content.split("\n")

            display_lines = lines[
                self.tool_calls_scroll : self.tool_calls_scroll + self.tool_height
            ]
            for i, line in enumerate(display_lines):
                if i < self.tool_height:
                    self.tool_calls_win.addstr(i, 0, line[: self.side_width - 2])

            self.tool_calls_win.refresh()
        except curses.error:
            pass

    def run(self):
        while True:
            try:

                self.textbox.clear()
                curses.curs_set(1)

                while True:
                    ch = self.stdscr.getch()

                    if ch == curses.KEY_MOUSE:
                        self.handle_mouse()
                    elif ch == 4:  # Ctrl-D
                        return
                    else:
                        if self.textbox.edit(ch):
                            break

                user_input = self.textbox.get_value()
                if not user_input.strip():
                    continue

                self.chat_history.append(f"You: {user_input.strip()}")
                tool_calls, response, raw, tools = get_chat_result(
                    self.conversation, user_input
                )
                if response is not None:
                    self.chat_history.append(f"Claude: {response}")
                self.raw_content = raw
                self.tool_calls_content = tool_calls

                formatted_lines = self.format_chat_history()
                self.chat_scroll = max(
                    0, len(formatted_lines) - (self.usable_height - 4)
                )
                self.update_chat_window()
                self.update_raw_window()
                self.update_tool_calls_window()
                
                tool_output = self.conversation.use_tools(tools)
                while tool_output is not None:
                    
                    # Parse the response to tool data
                    tags, response = parse_claude_output(tool_output)
                    if response is not None:
                        self.chat_history.append(f"Claude: {response}")
                    self.raw_content = tool_output
                    self.tool_calls_content = tools_to_str(tags)
                    
                    # Update the windows
                    self.update_chat_window()
                    self.update_raw_window()
                    self.update_tool_calls_window()
                    
                    # Try to once again respond to calls
                    if tags is not []:
                        tool_output = self.conversation.use_tools(tags)
                    else:
                        tool_output = None
                    

            except KeyboardInterrupt:
                return
            except curses.error:
                continue


def get_chat_result(
    conversation: Conversation, user_input: str
) -> Tuple[str, str, str, List[ParsedTag]]:
    output = conversation.query(user_input, channel=Channel.CHAT)
    assistant_block = conversation.last_assistant_block()
    raw_text = get_raw_text(assistant_block)

    tags, response = parse_claude_output(output)
    with open(ROOT / "logs" / "response_tags.txt", "w+") as f:
        f.write(f"{tags}")

    return tools_to_str(tags), response, raw_text, tags

def tools_to_str(tags: List[ParsedTag]) -> str:
    tool_calls = ""

    for tag in tags:
        tool_calls += f"Tool: {tag.tag} {tag.attributes}\n"
        tool_calls += f"Content: {tag.content}\n\n"
        
    return tool_calls

def main(stdscr) -> Conversation:
    curses.curs_set(1)
    stdscr.timeout(-1)

    conversation = Conversation(with_system_prompt=True)
    chat_tui = ChatTUI(stdscr, conversation)
    try:
        chat_tui.run()
    finally:
        signal.signal(signal.SIGWINCH, signal.SIG_DFL)


if __name__ == "__main__":
    curses.wrapper(main)
